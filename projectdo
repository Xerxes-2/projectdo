#!/bin/sh

# projectdo â€“ universal project commands.
# Copyright (C) 2019-present  Simon Friis Vindum

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

VERSION="0.2.0"

# Global mutable variables.
QUIET=false
DRY_RUN=false
PROJECT_ROOT="${PROJECT_ROOT:-}"
ACTION=""

has_command() {
  command -v "$1" >/dev/null 2>&1
}

# When running the appropriate external tool this function is used which
# evaluates the given command while respecting $QUIET and $DRY_RUN.
execute() {
  if [ $QUIET = false ]; then
    echo $1
  fi
  if [ $DRY_RUN = false ]; then
    if [ $QUIET = false ]; then
      eval $1
    else
      eval $1 > /dev/null
    fi
  fi
}

# Every supported tool requires two functions:
#
# 1/ A `detect_foo` function that returns 0 if the `foo` tool might be
#    appropriate in the current directory.
# 2/ A `run_foo` function that executes tests using the `foo` tool.
#
# Alternatively if separating detection and running is problematic then a
# single `detect_run_foo` function is used.

# Start list of tools

# JavaScript + NodeJS

detect_nodejs() {
  if [ ! -f package.json ]; then
    return 1
  fi
  if ! has_command "npm"; then
    echo "Found a package.json file but 'npm' is not installed."
    exit 1
  fi
  return 0
}

run_nodejs() {
  local node_action=$ACTION
  # Only the run action need translation, the others match 1-to-1
  if [ $ACTION = "run" ]; then
    node_action="start"
  fi
  # We found a package.json file, let's see if it contains an appropriate
  # script. We use grep for this, the check is not 100% bulletproof, but it's
  # very close. We could've used `npm run` to get the authorative list of the
  # scripts in the package.json, but invoking `npm` is two orders of magnitude
  # slower which leads to a noticeable delay.
  if ! grep -q "^[[:space:]]*\"${node_action}\":" package.json; then
    return 0
  fi
  if [ -f yarn.lock ]; then
    execute "yarn $node_action"
  else
    execute "npm $node_action"
  fi
  exit 0
}

# Rust + Cargo

detect_cargo() {
  [ -f Cargo.toml ]
}

run_cargo() {
  execute "cargo $ACTION"
  exit
}

# CMake

detect_cmake() {
  [ -f CMakeLists.txt ]
}

run_cmake() {
  if [ -f build ]; then
    execute "cmake --build build --target test"
  else
    execute "cmake --build . --target test"
  fi
}

# Haskell + Stack

detect_stack() {
  [ -f package.yaml -a -f stack.yaml ]
}

run_stack() {
  execute "stack test"
}

# Maven

detect_maven() {
  [ -f pom.xml ]
}

run_maven() {
  execute "mvn test"
}

# Clojure + Leiningen

detect_lein() {
  [ -f project.clj ]
}

run_lein() {
  execute "lein test"
}

# Makefile

has_make_target() {
    target="${1?}"
    output=$(make -n "${target}" 2>&1)
    exit_code=$?
    if [ $exit_code -ne 0 ]; then
        return $exit_code
    fi

    # If there is a file with the name of the target we're looking for but no
    # actual target with that name, make will exit successfully with that
    # message. We need to consider that case as a "target not found".
    if [ "${output}" = "make: Nothing to be done for '${target}'." ]; then
        return 1
    fi

    return 0
}

detect_run_makefile() {
  if [ -f Makefile ]; then
    if ! has_command "make"; then
      echo "Found a Makefile but 'make' is not installed."
      exit 1
    fi
    # We found a Makefile, let's see if it contains a test target.
    if has_make_target "test"; then
      execute "make test"
      exit
    elif has_make_target "check"; then
      execute "make check"
      exit
    fi
  fi
  return 1
}

# Python

detect_python() {
  [ -f pyproject.toml ]
}

run_python() {
  if grep -q -m 1 "^\[tool.poetry\]$" pyproject.toml; then
    # TODO: There are other Python test frameworks, it would be nice to detect
    # and run the right one.
    execute "poetry run pytest"
    exit
  else
    echo "Found a pyproject.toml file but t is not sure how to run it."
  fi
  return 1
}

# Go

detect_go() {
  [ -f go.mod ]
}

run_go() {
  # We detect Makefiles before we detect Go, so here we know that the Go
  # project is _not_ tested by a Makefile.

  # Check if the project uses Mage. A magefile could in theory have any name,
  # but `magefile.go` seems to be the convention.
  if grep -q -m 1 '^func Check(' magefile.go; then
    execute "mage check"
    return 0
  elif grep -q -m 1 '^func Test(' magefile.go; then
    execute "mage test"
    return 0
  fi
  execute "go test"
  return 0
}

# End of list of tools

detect_and_run() {
  if detect_nodejs; then
    run_nodejs
  fi
  if detect_cargo; then
    run_cargo
  fi
  # The remaining options has not been updated to support actions other than
  # `test`.
  if [ $ACTION = test ]; then
    if detect_cmake; then
      run_cmake
      exit
    elif detect_stack; then
      run_stack
      exit
    elif detect_maven; then
      run_maven
      exit
    elif detect_lein; then
      run_lein
      exit
    fi
    detect_run_makefile
    if detect_python; then
      run_python
      exit
    fi
    if detect_go; then
      run_go
      exit
    fi
  fi
}

set_project_root() {
  if [ -n "${PROJECT_ROOT}" ]; then
    return
  fi

  # Check if git exists on the system.
  if has_command "git"; then
    # Find the root of the git repository if we are inside one.
    PROJECT_ROOT=$(git rev-parse --show-toplevel 2> /dev/null)
    if [ $? -ne 0 ]; then
      # We are not in a git repository
      PROJECT_ROOT=$HOME
    fi
  fi
}

nothing_found() {
  echo "No way to $ACTION found :'("
  exit 1
}

display_version() {
  echo "$(basename "$0") version $VERSION"
}

display_help() {
  echo "Usage: $(basename "$0") [options] [action]
Options:
  -h, --help             Display this help.
  -n, -d, --dry-run      Do not execute any commands with side-effects.
  -q, --quiet            Do not print commands as they are about to be executed.
  -v, --version          Display the version of the program (which is $VERSION).

Actions:
  build, run, test       Build, run, or test the current project.
  print-tool             Output the guessed tool for the current project."
}

# Main execution starts here

while getopts dhnqv-: c
do
  case $c in
    d) DRY_RUN=true ;;
    h) display_help; exit 0 ;;
    n) DRY_RUN=true ;;
    q) QUIET=true ;;
    v) display_version; exit 0 ;;
    -) case $OPTARG in
         help) display_help; exit 0 ;;
         dry-run) DRY_RUN=true ;;
         quiet) QUIET=true ;;
         version) display_version; exit 0 ;;
         '' ) break ;; # "--" should terminate argument processing
         * ) echo "Illegal option --$OPTARG" >&2; exit 1 ;;
      esac ;;
    \?) exit 1 ;;
  esac
done

shift $((OPTIND-1)) # Shift away the parsed option arguments

if [ "$1" = "test" ] ||
   [ "$1" = "run" ] ||
   [ "$1" = "build" ] ||
   [ "$1" = "print-tool" ]; then
  ACTION=$1
else
  if [ -z "$1" ]; then
    echo "No action specified."
  else
    echo "$1 is not a valid action."
  fi
  echo ""
  echo "The valid actions are: build, run, test, print-tool"
  echo ""
  echo "Example: projectdo test"
  exit 1
fi

set_project_root

while :
do
  detect_and_run
  # If we didn't detect a tool to run in this directory we go one directory up
  # while ensuring that we don't leave the current project and don't enter the
  # home directory.
  if [ $PWD = $PROJECT_ROOT ]; then
    nothing_found
  fi
  cd ..
  if [ $PWD = $HOME ]; then
    nothing_found
  fi
done
